---
layout: post
title: Unit testing Angular promises with Jasmine spies & the power of $q
date: '2015-03-22T16:26:00.001-07:00'
author: Mark Corkery
tags:
- jasmine
- promises
- angular
modified_time: '2015-04-12T13:43:08.973-07:00'
blogger_id: tag:blogger.com,1999:blog-7218688161043116845.post-7231274156907956830
blogger_orig_url: http://markcorkery.blogspot.com/2015/03/unit-testing-angular-promises-with.html
---

I've been really impressed with the way that the angular community have put in so many clever design decisions that make it really easy to unit test your angular code. I wanted to share a couple of techniques I recently came across that help with testing Angular promises.<br /><br />For those unfamiliar with what an Angular promise is, it's basically a way of wrapping an asynchronous call to another function. The promise basically covers the fact that while you may not get the answer when you call it right now (which would make it synchronous), you are promised a response at some future point. This&nbsp;<a href="http://andyshora.com/promises-angularjs-explained-as-cartoon.html" target="_blank">excellent article explains it much better than I ever could</a>&nbsp;so check it out.<br /><br />First off, here's our code that we want to test. You can see that this method makes use of an external service, called externalService :D, which returns a promise that our calling method must react to. In both successful and failure cases we'll emit an event to display the result of the promise.<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28</pre></td><td><pre style="line-height: 125%; margin: 0;">    $scope.uploadFile<span style="color: #333333;">=</span> <span style="color: #008800; font-weight: bold;">function</span>(fileContent) {<br />        $scope.hideModal();<br />        externalService.postContents(fileContent).then(<span style="color: #008800; font-weight: bold;">function</span>(response) {<br />            $scope.reactToUpdate();<br />            <span style="color: #008800; font-weight: bold;">var</span> successCount <span style="color: #333333;">=</span> response.data.successCount;<br />            <span style="color: #008800; font-weight: bold;">var</span> errorCount <span style="color: #333333;">=</span> response.data.errorCount;<br />            <span style="color: #008800; font-weight: bold;">var</span> message <span style="color: #333333;">=</span> <span style="background-color: #fff0f0;">"Posted "</span> <span style="color: #333333;">+</span> successCount <span style="color: #333333;">+</span> <span style="background-color: #fff0f0;">" elements with "</span> <span style="color: #333333;">+</span> errorCount <span style="color: #333333;">+</span> <span style="background-color: #fff0f0;">" errors"</span>;<br />            <span style="color: #008800; font-weight: bold;">var</span> informationModalData <span style="color: #333333;">=</span> {<br />                title <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"Elements successfully posted"</span>,<br />                message <span style="color: #333333;">:</span> message,<br />                type <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"success"</span>,<br />                autoDismiss <span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">true</span><br />            };<br />            $scope.$emit(<span style="background-color: #fff0f0;">"showInformationModal"</span>, informationModalData);<br />            console.log(<span style="background-color: #fff0f0;">"Posted "</span> <span style="color: #333333;">+</span> successCount <span style="color: #333333;">+</span> <span style="background-color: #fff0f0;">" elements successfully, with "</span> <span style="color: #333333;">+</span> errorCount <span style="color: #333333;">+</span> <span style="background-color: #fff0f0;">" errors."</span>);<br /><br />        }, <span style="color: #008800; font-weight: bold;">function</span>(reason) {<br />            <span style="color: #008800; font-weight: bold;">var</span> errorMessage <span style="color: #333333;">=</span> reason.data.message;<br />            <span style="color: #008800; font-weight: bold;">var</span> informationModalData <span style="color: #333333;">=</span> {<br />                title <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"Failed to post elements"</span>,<br />                message <span style="color: #333333;">:</span> errorMessage,<br />                type <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"failure"</span>,<br />                autoDismiss <span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">true</span><br />            };<br />            $scope.$emit(<span style="background-color: #fff0f0;">"showInformationModal"</span>, informationModalData);<br />        });<br /><br />    };<br /></pre></td></tr></tbody></table></div><h3>&nbsp;Technique Number One - Using Provide and Spy</h3><div>I came across this when reading&nbsp;<a href="http://ng-learn.org/2014/08/Testing_Promises_with_Jasmine_Provide_Spy/" target="_blank">this article</a>&nbsp;over on ng-learn and it covers it in pretty good detail so follow the link to get the full description, but basically, by using the <a href="https://docs.angularjs.org/api/auto/service/$provide" target="_blank">$provide</a> mechanism in angular we can register mock implementations of our external service and then $inject that into our tests in order to drive the expected flows through our code being tested. In lines 4 - 10 below we are using $provide to register our own implementation of the externalService to return a data structure representing a valid response. It is this implementation of externalService that is injected into our object under test in line 13.<br /><br /></div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25</pre></td><td><pre style="line-height: 125%; margin: 0;">    beforeEach(<span style="color: #008800; font-weight: bold;">function</span>() {<br />        module(<span style="background-color: #fff0f0;">'postContentsModule'</span>);<br />        module(<span style="color: #008800; font-weight: bold;">function</span>($provide) {<br />            $provide.value(<span style="background-color: #fff0f0;">'externalService'</span>, {<br />                postContents<span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">function</span>() {<br />                    <span style="color: #008800; font-weight: bold;">return</span> {<br />                        then<span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">function</span>(callback) {<span style="color: #008800; font-weight: bold;">return</span> callback({ data<span style="color: #333333;">:</span>  {successCount<span style="color: #333333;">:</span> <span style="color: #0000dd; font-weight: bold;">2</span>, errorCount<span style="color: #333333;">:</span> <span style="color: #0000dd; font-weight: bold;">0</span>}});}<br />                    };<br />                }<br />                });<br />            });<br />    <br />        inject(<span style="color: #008800; font-weight: bold;">function</span>($rootScope, $compile, $controller, _externalService_, $q) {<br />            scope <span style="color: #333333;">=</span> $rootScope.$new();<br />            scope.reactToUpdate <span style="color: #333333;">=</span> <span style="color: #008800; font-weight: bold;">function</span>() {};<br />            externalService <span style="color: #333333;">=</span> _externalService_;<br />            compile <span style="color: #333333;">=</span> $compile;<br />            q <span style="color: #333333;">=</span> $q;<br />            postContentsController <span style="color: #333333;">=</span> $controller(<span style="background-color: #fff0f0;">'postContentsCtrl'</span>, {<br />                <span style="background-color: #fff0f0;">'$scope'</span> <span style="color: #333333;">:</span> scope<br />            });<br />            element <span style="color: #333333;">=</span> compile(<span style="background-color: #fff0f0;">'&lt;<span style="line-height: 125%;">post-contents</span><span style="line-height: 125%;">&gt;&lt;/post-contents&gt;'</span><span style="background-color: transparent; line-height: 125%;">)(scope);</span></span>            scope.$digest();<br />        });<br />    });<br /></pre></td></tr></tbody></table></div><div><br />This implementation is then used in our tests as shown below. We set up the spy to call through to our externalService whose response helps us test any flows in the .then statement of our code:<br /><br /><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14<br />15<br />16<br />17<br />18<br />19<br />20<br />21<br />22<br />23<br />24<br />25<br />26<br />27<br />28<br />29<br />30</pre></td><td><pre style="line-height: 125%; margin: 0;">    describe(<span style="background-color: #fff0f0;">"tests on successful post"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />        beforeEach(<span style="color: #008800; font-weight: bold;">function</span>() {<br />            spyOn(externalService, <span style="background-color: #fff0f0;">'importServices'</span>).andCallThrough();<br />            spyOn(scope, <span style="background-color: #fff0f0;">'reactToUpdate'</span>);<br />            spyOn(scope, <span style="background-color: #fff0f0;">'$emit'</span>);<br />            spyOn(scope, <span style="background-color: #fff0f0;">'hideModal'</span>).andCallThrough();<br />            scope.showModal();<br />            scope.$digest();<br />        });<br />        it(<span style="background-color: #fff0f0;">"should invoke postContents"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />            scope.uploadFile(<span style="background-color: #fff0f0;">"text"</span>);<br />            expect(externalService.postContents).toHaveBeenCalled();<br />            });<br />        it(<span style="background-color: #fff0f0;">"should invoke reactToUpdate on the scope"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />            scope.uploadFile(<span style="background-color: #fff0f0;">"text"</span>);<br />            expect(scope.reactToUpdate).toHaveBeenCalled();<br />            });<br />        it(<span style="background-color: #fff0f0;">"should invoke emit event for displaying success"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />            scope.uploadFile(<span style="background-color: #fff0f0;">"text"</span>);<br />            expect(scope.$emit).toHaveBeenCalledWith(<span style="background-color: #fff0f0;">'showInformationModal'</span>, { title <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'Services successfully imported'</span>, message <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'Posted 2 elements with 0 errors'</span>, type <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'success'</span>, autoDismiss <span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">true</span> });<br />            });<br />        it(<span style="background-color: #fff0f0;">"should invoke hideModal"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />            scope.uploadFile(<span style="background-color: #fff0f0;">"text"</span>);<br />            scope.$digest();<br />            expect(scope.hideModal).toHaveBeenCalled();<br />            <br />            expect(angular.element(element[<span style="color: #0000dd; font-weight: bold;">0</span>].querySelector(<span style="background-color: #fff0f0;">'#modalOverlay'</span>)).hasClass(<span style="background-color: #fff0f0;">'ng-hide'</span>)).toBe(<span style="color: #008800; font-weight: bold;">true</span>);<br />            expect(angular.element(element[<span style="color: #0000dd; font-weight: bold;">0</span>].querySelector(<span style="background-color: #fff0f0;">'#postContentsModal'</span>)).hasClass(<span style="background-color: #fff0f0;">'ng-hide'</span>)).toBe(<span style="color: #008800; font-weight: bold;">true</span>);<br />            });<br />    });<br /></pre></td></tr></tbody></table></div><br />Note that instead of calling through to the externalService, you can also use a fake implementation as outlined in that previously mentioned <a href="http://ng-learn.org/2014/08/Testing_Promises_with_Jasmine_Provide_Spy/" target="_blank">article</a>.<br /><h3>Technique Two - The power of $q</h3></div><div>Using the technique above I was able to test out the positive path of our promise, but I just couldn't see anyway to test the negative condition using $provide. It was then that I found another technique of testing promises by making use of the <a href="https://docs.angularjs.org/api/ng/service/$q" target="_blank">deferred object $q</a> as outlined <a href="http://www.antonydenyer.co.uk/blog/2014/07/29/mocking-promise-based-services-in-angularjs/" target="_blank">here</a>. The $q object is what Angular uses for asynchronous calls and it can also be used when testing your own code.<br /><br />Quite simply, you construct a new deferred object (line 4) and using the spyOn method from Jasmine we set the response of the postContents method to be our deferred object. Then when we actually go to test the function, we can instruct our deferred object to actually return an error or rejected response as shown in line 10.<br /><br />This same technique can be used for testing positive flows by calling deferred.resolve instead fo deferred.reject.<br /><br /></div><!-- HTML generated using hilite.me --><br /><div style="background: #ffffff; border-width: .1em .1em .1em .8em; border: solid gray; overflow: auto; padding: .2em .6em; width: auto;"><table><tbody><tr><td><pre style="line-height: 125%; margin: 0;"> 1<br /> 2<br /> 3<br /> 4<br /> 5<br /> 6<br /> 7<br /> 8<br /> 9<br />10<br />11<br />12<br />13<br />14</pre></td><td><pre style="line-height: 125%; margin: 0;">    describe(<span style="background-color: #fff0f0;">"tests on unsuccessful post"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />        <span style="color: #008800; font-weight: bold;">var</span> deferredFailure;<br />        beforeEach(<span style="color: #008800; font-weight: bold;">function</span>() {<br />            deferredFailure <span style="color: #333333;">=</span> q.defer();<br />            spyOn(externalService, <span style="background-color: #fff0f0;">'postContents'</span>).andReturn(deferredFailure.promise);<br />            spyOn(scope, <span style="background-color: #fff0f0;">'$emit'</span>);<br />        });<br />        it(<span style="background-color: #fff0f0;">"should invoke emit event for displaying failure"</span>, <span style="color: #008800; font-weight: bold;">function</span>() {<br />            scope.uploadFile(<span style="background-color: #fff0f0;">"text"</span>);<br />            deferredFailure.reject({ data<span style="color: #333333;">:</span>  {message<span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">"wrong"</span>}});<br />            scope.$digest();<br />            expect(scope.$emit).toHaveBeenCalledWith(<span style="background-color: #fff0f0;">'showInformationModal'</span>, { title <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'Failed to post elements'</span>, message <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'wrong'</span>, type <span style="color: #333333;">:</span> <span style="background-color: #fff0f0;">'failure'</span>, autoDismiss <span style="color: #333333;">:</span> <span style="color: #008800; font-weight: bold;">true</span> });<br />            });<br />    });<br /></pre></td></tr></tbody></table></div><div><br /></div>